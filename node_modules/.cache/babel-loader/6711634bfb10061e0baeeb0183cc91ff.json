{"ast":null,"code":"import _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\n\n\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\n\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n\n  var values = _range(domainMin, domainMax, step);\n\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n\n  var rules = function (datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n\n  var sanitize = function (datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    } else {\n      return datum;\n    }\n  });\n} // Exported Functions\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\n\n\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  var exists = function (val) {\n    return val !== undefined;\n  };\n\n  var minDomainX = Collection.getMinValue(domain.x);\n  var maxDomainX = Collection.getMaxValue(domain.x);\n  var minDomainY = Collection.getMinValue(domain.y);\n  var maxDomainY = Collection.getMaxValue(domain.y);\n\n  var underMin = function (min) {\n    return function (val) {\n      return exists(val) && val < min;\n    };\n  };\n\n  var overMax = function (max) {\n    return function (val) {\n      return exists(val) && val > max;\n    };\n  };\n\n  var isUnderMinX = underMin(minDomainX);\n  var isUnderMinY = underMin(minDomainY);\n  var isOverMaxX = overMax(maxDomainX);\n  var isOverMaxY = overMax(maxDomainY); // eslint-disable-next-line complexity\n\n  return dataset.map(function (datum) {\n    var _x = datum._x,\n        _y = datum._y,\n        _y0 = datum._y0,\n        _y1 = datum._y1; // single x point less than min domain\n\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    var baseline = exists(_y0) ? _y0 : defaultBaseline;\n    var value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum; // value only and less than min domain or greater than max domain\n\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null; // baseline and value are both less than min domain or both greater than max domain\n\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null; // baseline and value with only baseline below min, set baseline to minDomainY\n\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY; // baseline and value with only baseline above max, set baseline to maxDomainY\n\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return _assign({}, datum, _omitBy({\n      _x: _x,\n      _y: _y,\n      _y0: _y0,\n      _y1: _y1\n    }, _isUndefined));\n  });\n}\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\nexport function createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n\n  var allStrings = _uniq(_toConsumableArray(stringsFromAxes).concat(_toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\nexport function downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // ensures that the downampling of data while zooming looks good.\n\n  var dataLength = getLength(data);\n\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter( // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\nexport function formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n\n  var createAccessor = function (name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    var formattedDatum = _assign({}, processedValues, datum);\n\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n      tickFormat = props.tickFormat;\n  var tickValueArray;\n\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n\n  if (!isArrayOrIterable) {\n    return [];\n  }\n\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDataComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}","map":{"version":3,"sources":["C:/Users/31622/Documents/React Apps/portfolio/node_modules/victory-core/es/victory-util/data.js"],"names":["_omitBy","_isUndefined","_includes","_isEqual","_isEmpty","_orderBy","_property","_isPlainObject","_isFunction","_last","_range","_uniq","_assign","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","React","Helpers","Collection","Scale","Immutable","parseDatum","datum","immutableDatumWhitelist","errorX","errorY","isImmutable","shallowToJS","getLength","data","isIterable","size","generateDataArray","props","axis","propsDomain","domain","getBaseScale","samples","domainMax","Math","max","apply","domainMin","min","step","values","concat","sortData","dataset","sortKey","sortOrder","arguments","undefined","order","cleanData","smallNumber","Number","MAX_SAFE_INTEGER","scaleType","x","getScaleType","y","rules","sanitize","_x","_y","_y0","map","getEventKey","key","addEventKeys","hasEventKeyAccessor","eventKey","eventKeyAccessor","index","formatDataFromDomain","defaultBaseline","exists","val","minDomainX","getMinValue","maxDomainX","getMaxValue","minDomainY","maxDomainY","underMin","overMax","isUnderMinX","isUnderMinY","isOverMaxX","isOverMaxY","_y1","baseline","value","createStringMap","stringsFromAxes","getStringsFromAxes","stringsFromCategories","getStringsFromCategories","stringsFromData","getStringsFromData","allStrings","reduce","memo","string","downsample","maxPoints","startingIndex","dataLength","k","pow","ceil","log2","filter","d","formatData","expectedKeys","isArrayOrIterable","defaultKeys","createAccessor","name","accessor","type","preformattedData","y0","stringMap","indexOf","dataArr","fallbackValues","processedValues","processedValue","formattedDatum","push","sortedData","cleanedData","generateData","xValues","yValues","getCategories","categories","getData","tickValues","tickFormat","tickValueArray","categoryStrings","removeUndefined","dataStrings","prev","curr","isDataComponent","component","getRole","child","role","children","Children","toArray","whitelist"],"mappings":"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","sourcesContent":["import _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _last from \"lodash/last\";\nimport _range from \"lodash/range\";\nimport _uniq from \"lodash/uniq\";\nimport _assign from \"lodash/assign\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n/* eslint-disable func-style */\n\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\"; // Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\n\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n} // Returns generated data for a given axis based on domain and sample from props\n\n\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n\n  var values = _range(domainMin, domainMax, step);\n\n  return _last(values) === domainMax ? values : values.concat(domainMax);\n} // Returns sorted data. If no sort keys are provided, data is returned unaltered.\n\n\nfunction sortData(dataset, sortKey) {\n  var sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ascending\";\n\n  if (!sortKey) {\n    return dataset;\n  } // Ensures previous VictoryLine api for sortKey prop stays consistent\n\n\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    sortKey = \"_\".concat(sortKey);\n  }\n\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, sortKey, order);\n} // This method will remove data points that break certain scales. (log scale only)\n\n\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n\n  var rules = function (datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n\n  var sanitize = function (datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n\n    return _assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n\n    return sanitize(datum);\n  });\n} // Returns a data accessor given an eventKey prop\n\n\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (_isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  } // otherwise, assume it is an array index, property key or path (_.property handles all three)\n\n\n  return _property(key);\n} // Returns data with an eventKey prop added to each datum\n\n\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? _assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    } else {\n      return datum;\n    }\n  });\n} // Exported Functions\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\n\n\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  var exists = function (val) {\n    return val !== undefined;\n  };\n\n  var minDomainX = Collection.getMinValue(domain.x);\n  var maxDomainX = Collection.getMaxValue(domain.x);\n  var minDomainY = Collection.getMinValue(domain.y);\n  var maxDomainY = Collection.getMaxValue(domain.y);\n\n  var underMin = function (min) {\n    return function (val) {\n      return exists(val) && val < min;\n    };\n  };\n\n  var overMax = function (max) {\n    return function (val) {\n      return exists(val) && val > max;\n    };\n  };\n\n  var isUnderMinX = underMin(minDomainX);\n  var isUnderMinY = underMin(minDomainY);\n  var isOverMaxX = overMax(maxDomainX);\n  var isOverMaxY = overMax(maxDomainY); // eslint-disable-next-line complexity\n\n  return dataset.map(function (datum) {\n    var _x = datum._x,\n        _y = datum._y,\n        _y0 = datum._y0,\n        _y1 = datum._y1; // single x point less than min domain\n\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    var baseline = exists(_y0) ? _y0 : defaultBaseline;\n    var value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum; // value only and less than min domain or greater than max domain\n\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null; // baseline and value are both less than min domain or both greater than max domain\n\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null; // baseline and value with only baseline below min, set baseline to minDomainY\n\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY; // baseline and value with only baseline above max, set baseline to maxDomainY\n\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return _assign({}, datum, _omitBy({\n      _x: _x,\n      _y: _y,\n      _y0: _y0,\n      _y1: _y1\n    }, _isUndefined));\n  });\n}\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\n\nexport function createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n\n  var allStrings = _uniq(_toConsumableArray(stringsFromAxes).concat(_toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\n\nexport function downsample(data, maxPoints) {\n  var startingIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // ensures that the downampling of data while zooming looks good.\n  var dataLength = getLength(data);\n\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter( // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n\n  return data;\n}\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\n\nexport function formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n\n  var createAccessor = function (name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    datum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: datum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](datum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n\n      return memo;\n    }, {});\n\n    var formattedDatum = _assign({}, processedValues, datum);\n\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\n\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\n\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n      tickFormat = props.tickFormat;\n  var tickValueArray;\n\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\n\nexport function getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n\n  if (!isArrayOrIterable) {\n    return [];\n  }\n\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key); // support immutable data\n\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    datum = parseDatum(datum);\n    dataArr.push(accessor(datum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  }); // return a unique set of strings\n\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n\n    return prev;\n  }, []);\n}\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\n\nexport function isDataComponent(component) {\n  var getRole = function (child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n\n  var role = getRole(component);\n\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return _includes(whitelist, role);\n}"]},"metadata":{},"sourceType":"module"}