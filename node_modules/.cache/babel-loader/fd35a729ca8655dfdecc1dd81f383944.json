{"ast":null,"code":"import _keys from \"lodash/keys\";\nimport _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport _assign from \"lodash/assign\";\nimport React from \"react\";\n\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\n\nfunction getKeyedData(data) {\n  return data.reduce(function (keyedData, datum, idx) {\n    var key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\n\nfunction getKeyedDataDifference(a, b) {\n  var hasDifference = false;\n\n  var difference = _keys(a).reduce(function (_difference, key) {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n\n    return _difference;\n  }, {});\n\n  return hasDifference && difference;\n}\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\n\n\nfunction getNodeTransitions(oldData, nextData) {\n  var oldDataKeyed = oldData && getKeyedData(oldData);\n  var nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\n\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n\n  return child.props && child.props.data || false;\n}\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\n\n\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  var nodesWillExit = false;\n  var nodesWillEnter = false;\n\n  var getTransition = function (oldChild, newChild) {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n\n    var _ref = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {},\n        entering = _ref.entering,\n        exiting = _ref.exiting;\n\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n\n  var getTransitionsFromChildren = function (old, next) {\n    return old.map(function (child, idx) {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      } // get Transition entering and exiting nodes\n\n\n      return getTransition(child, next[idx]);\n    });\n  };\n\n  var childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit: nodesWillExit,\n    nodesWillEnter: nodesWillEnter,\n    childrenTransitions: childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\n\nfunction getInitialChildProps(animate, data) {\n  var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map(function (datum, idx) {\n      return _assign({}, datum, after(datum, idx, data));\n    })\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var before = animate.onLoad && animate.onLoad.before ? animate.onLoad.before : _identity; // If nodes need to exit, transform them with the provided onLoad.before function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data,\n    clipWidth: 0\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildOnLoad(animate, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity; // If nodes need to exit, transform them with the provided onLoad.after function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  var onExit = animate && animate.onExit;\n  animate = _assign({}, animate, onExit);\n\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting or entering.\n    animate.onEnd = cb;\n    var before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity; // If nodes need to exit, transform them with the provided onExit.before function.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return exitingNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params,max-len\n\n\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    animate = _assign({}, animate, {\n      onEnd: cb\n    });\n    var before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity; // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return enteringNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  var onEnter = animate && animate.onEnter;\n  animate = _assign({}, animate, onEnter);\n\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    animate.onEnd = cb;\n    var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n    data = data.map(function (datum, idx) {\n      var key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? _assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n}\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchoronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\n\n\nexport function getTransitionPropsFactory(props, state, setState) {\n  var nodesWillExit = state && state.nodesWillExit;\n  var nodesWillEnter = state && state.nodesWillEnter;\n  var nodesShouldEnter = state && state.nodesShouldEnter;\n  var nodesShouldLoad = state && state.nodesShouldLoad;\n  var nodesDoneLoad = state && state.nodesDoneLoad;\n  var childrenTransitions = state && state.childrenTransitions || [];\n  var transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n\n  var onLoad = function (child, data, animate) {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, function () {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n\n    return getChildBeforeLoad(animate, child, data, function () {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onExit = function (nodes, child, data, animate) {\n    return getChildPropsOnExit(animate, child, data, nodes, function () {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onEnter = function (nodes, child, data, animate) {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, function () {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n\n    return getChildPropsBeforeEnter(animate, child, data, nodes, function () {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n\n  var getChildTransitionDuration = function (child, type) {\n    var animate = child.props.animate;\n\n    if (!child.type) {\n      return {};\n    }\n\n    var defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n\n    if (defaultTransitions) {\n      var animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    } else {\n      return {};\n    }\n  }; // eslint-disable-next-line max-statements, complexity, max-len\n\n\n  return function getTransitionProps(child, index) {\n    var data = getChildData(child) || [];\n\n    var animate = _defaults({}, props.animate, child.props.animate);\n\n    var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    var childTransitions = childrenTransitions[index] || childrenTransitions[0];\n\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      var load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      var animation = {\n        duration: load\n      };\n      return onLoad(child, data, _assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      var exitingNodes = childTransitions && childTransitions.exiting;\n      var exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\"); // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n\n      var _animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n\n      return onExit(exitingNodes, child, data, _assign({}, animate, _animation));\n    } else if (nodesWillEnter) {\n      var enteringNodes = childTransitions && childTransitions.entering;\n      var enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      var move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      var _animation2 = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, _assign({}, animate, _animation2));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n\n    return {\n      animate: animate,\n      data: data\n    };\n  };\n}","map":{"version":3,"sources":["C:/Users/31622/Documents/React Apps/portfolio/node_modules/victory-core/es/victory-util/transitions.js"],"names":["_keys","_identity","_defaults","_assign","React","getDatumKey","datum","idx","key","toString","getKeyedData","data","reduce","keyedData","getKeyedDataDifference","a","b","hasDifference","difference","_difference","getNodeTransitions","oldData","nextData","oldDataKeyed","nextDataKeyed","entering","exiting","getChildData","child","type","getData","props","getInitialTransitionState","oldChildren","nextChildren","nodesWillExit","nodesWillEnter","getTransition","oldChild","newChild","_ref","getTransitionsFromChildren","old","next","map","children","Children","toArray","childrenTransitions","nodesShouldEnter","getInitialChildProps","animate","after","onEnter","getChildBeforeLoad","cb","onEnd","onLoad","duration","before","clipWidth","getChildOnLoad","getChildPropsOnExit","exitingNodes","onExit","getChildPropsBeforeEnter","enteringNodes","getChildPropsOnEnter","getTransitionPropsFactory","state","setState","nodesShouldLoad","nodesDoneLoad","transitionDurations","enter","exit","load","move","nodes","getChildTransitionDuration","defaultTransitions","polar","defaultPolarTransitions","animationDuration","undefined","getTransitionProps","index","childTransitions","animation","_animation","delay","_animation2"],"mappings":"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","sourcesContent":["import _keys from \"lodash/keys\";\nimport _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport _assign from \"lodash/assign\";\nimport React from \"react\";\n\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\n\nfunction getKeyedData(data) {\n  return data.reduce(function (keyedData, datum, idx) {\n    var key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\n\nfunction getKeyedDataDifference(a, b) {\n  var hasDifference = false;\n\n  var difference = _keys(a).reduce(function (_difference, key) {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n\n    return _difference;\n  }, {});\n\n  return hasDifference && difference;\n}\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\n\n\nfunction getNodeTransitions(oldData, nextData) {\n  var oldDataKeyed = oldData && getKeyedData(oldData);\n  var nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\n\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n\n  return child.props && child.props.data || false;\n}\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\n\n\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  var nodesWillExit = false;\n  var nodesWillEnter = false;\n\n  var getTransition = function (oldChild, newChild) {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n\n    var _ref = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {},\n        entering = _ref.entering,\n        exiting = _ref.exiting;\n\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n\n  var getTransitionsFromChildren = function (old, next) {\n    return old.map(function (child, idx) {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      } // get Transition entering and exiting nodes\n\n\n      return getTransition(child, next[idx]);\n    });\n  };\n\n  var childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit: nodesWillExit,\n    nodesWillEnter: nodesWillEnter,\n    childrenTransitions: childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\n\nfunction getInitialChildProps(animate, data) {\n  var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map(function (datum, idx) {\n      return _assign({}, datum, after(datum, idx, data));\n    })\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var before = animate.onLoad && animate.onLoad.before ? animate.onLoad.before : _identity; // If nodes need to exit, transform them with the provided onLoad.before function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data,\n    clipWidth: 0\n  };\n} // eslint-disable-next-line max-params\n\n\nfunction getChildOnLoad(animate, data, cb) {\n  animate = _assign({}, animate, {\n    onEnd: cb\n  });\n\n  if (animate && animate.onLoad && !animate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n\n  var after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity; // If nodes need to exit, transform them with the provided onLoad.after function.\n\n  data = data.map(function (datum, idx) {\n    return _assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  var onExit = animate && animate.onExit;\n  animate = _assign({}, animate, onExit);\n\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting or entering.\n    animate.onEnd = cb;\n    var before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity; // If nodes need to exit, transform them with the provided onExit.before function.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return exitingNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params,max-len\n\n\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    animate = _assign({}, animate, {\n      onEnd: cb\n    });\n    var before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity; // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n\n    data = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return enteringNodes[key] ? _assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n} // eslint-disable-next-line max-params, max-len\n\n\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  var onEnter = animate && animate.onEnter;\n  animate = _assign({}, animate, onEnter);\n\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    animate.onEnd = cb;\n    var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n    data = data.map(function (datum, idx) {\n      var key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? _assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n\n  return {\n    animate: animate,\n    data: data\n  };\n}\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchoronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\n\n\nexport function getTransitionPropsFactory(props, state, setState) {\n  var nodesWillExit = state && state.nodesWillExit;\n  var nodesWillEnter = state && state.nodesWillEnter;\n  var nodesShouldEnter = state && state.nodesShouldEnter;\n  var nodesShouldLoad = state && state.nodesShouldLoad;\n  var nodesDoneLoad = state && state.nodesDoneLoad;\n  var childrenTransitions = state && state.childrenTransitions || [];\n  var transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n\n  var onLoad = function (child, data, animate) {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, function () {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n\n    return getChildBeforeLoad(animate, child, data, function () {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onExit = function (nodes, child, data, animate) {\n    return getChildPropsOnExit(animate, child, data, nodes, function () {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  }; // eslint-disable-next-line max-params\n\n\n  var onEnter = function (nodes, child, data, animate) {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, function () {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n\n    return getChildPropsBeforeEnter(animate, child, data, nodes, function () {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n\n  var getChildTransitionDuration = function (child, type) {\n    var animate = child.props.animate;\n\n    if (!child.type) {\n      return {};\n    }\n\n    var defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n\n    if (defaultTransitions) {\n      var animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    } else {\n      return {};\n    }\n  }; // eslint-disable-next-line max-statements, complexity, max-len\n\n\n  return function getTransitionProps(child, index) {\n    var data = getChildData(child) || [];\n\n    var animate = _defaults({}, props.animate, child.props.animate);\n\n    var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    var childTransitions = childrenTransitions[index] || childrenTransitions[0];\n\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      var load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      var animation = {\n        duration: load\n      };\n      return onLoad(child, data, _assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      var exitingNodes = childTransitions && childTransitions.exiting;\n      var exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\"); // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n\n      var _animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n\n      return onExit(exitingNodes, child, data, _assign({}, animate, _animation));\n    } else if (nodesWillEnter) {\n      var enteringNodes = childTransitions && childTransitions.entering;\n      var enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      var move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      var _animation2 = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, _assign({}, animate, _animation2));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n\n    return {\n      animate: animate,\n      data: data\n    };\n  };\n}"]},"metadata":{},"sourceType":"module"}