{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"]; // Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nfunction validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return props.scale[axis] ? true : false;\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nexport function getScaleFromName(name) {\n  return validScale(name) ? d3Scale[toNewName(name)]() : d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return d3Scale[toNewName(defaultScale)]();\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : d3Scale[toNewName(scale)]();\n  }\n\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n}\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var duckTypes = [{\n    name: \"log\",\n    method: \"base\"\n  }, {\n    name: \"ordinal\",\n    method: \"unknown\"\n  }, {\n    name: \"pow-sqrt\",\n    method: \"exponent\"\n  }, {\n    name: \"quantile\",\n    method: \"quantiles\"\n  }, {\n    name: \"quantize-threshold\",\n    method: \"invertExtent\"\n  }];\n  var scaleType = duckTypes.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}","map":{"version":3,"sources":["C:/Users/31622/Documents/React Apps/portfolio/node_modules/victory-core/es/victory-util/scale.js"],"names":["_isPlainObject","_isFunction","_includes","Helpers","Collection","d3Scale","supportedScaleStrings","toNewName","scale","capitalize","s","toUpperCase","slice","concat","validScale","copy","domain","range","isScaleDefined","props","axis","x","y","getScaleTypeFromProps","undefined","getType","getScaleFromDomain","Array","isArray","containsDates","getScaleTypeFromData","data","accessor","createAccessor","axisData","map","datum","processedData","getScaleFromName","name","scaleLinear","getBaseScale","getScaleFromProps","defaultScale","getDefaultScale","getScaleType","duckTypes","method","scaleType","filter","type"],"mappings":"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","sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport _isFunction from \"lodash/isFunction\";\nimport _includes from \"lodash/includes\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"d3-scale\";\nvar supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"]; // Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  var capitalize = function (s) {\n    return s && s[0].toUpperCase() + s.slice(1);\n  };\n\n  return \"scale\".concat(capitalize(scale));\n}\n\nfunction validScale(scale) {\n  if (typeof scale === \"function\") {\n    return _isFunction(scale.copy) && _isFunction(scale.domain) && _isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return _includes(supportedScaleStrings, scale);\n  }\n\n  return false;\n}\n\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return props.scale[axis] ? true : false;\n  }\n\n  return true;\n}\n\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\n\nfunction getScaleFromDomain(props, axis) {\n  var domain;\n\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n\n  if (!domain) {\n    return undefined;\n  }\n\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\n\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n\n  var accessor = Helpers.createAccessor(props[axis]);\n  var axisData = props.data.map(function (datum) {\n    var processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n} // Exported Functions\n\n\nexport function getScaleFromName(name) {\n  return validScale(name) ? d3Scale[toNewName(name)]() : d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  var scale = getScaleFromProps(props, axis);\n\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n\n  var defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return d3Scale[toNewName(defaultScale)]();\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n\n  var scale = props.scale[axis] || props.scale;\n\n  if (validScale(scale)) {\n    return _isFunction(scale) ? scale : d3Scale[toNewName(scale)]();\n  }\n\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n}\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n\n  var duckTypes = [{\n    name: \"log\",\n    method: \"base\"\n  }, {\n    name: \"ordinal\",\n    method: \"unknown\"\n  }, {\n    name: \"pow-sqrt\",\n    method: \"exponent\"\n  }, {\n    name: \"quantile\",\n    method: \"quantiles\"\n  }, {\n    name: \"quantize-threshold\",\n    method: \"invertExtent\"\n  }];\n  var scaleType = duckTypes.filter(function (type) {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}"]},"metadata":{},"sourceType":"module"}