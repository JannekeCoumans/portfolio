{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.Delaunator = factory());\n})(this, function () {\n  'use strict';\n\n  var EPSILON = Math.pow(2, -52);\n  var EDGE_STACK = new Uint32Array(512);\n\n  var Delaunator = function Delaunator(coords) {\n    var n = coords.length >> 1;\n\n    if (n > 0 && typeof coords[0] !== 'number') {\n      throw new Error('Expected coords to contain numbers.');\n    }\n\n    this.coords = coords; // arrays that will store the triangulation graph\n\n    var maxTriangles = Math.max(2 * n - 5, 0);\n    this._triangles = new Uint32Array(maxTriangles * 3);\n    this._halfedges = new Int32Array(maxTriangles * 3); // temporary arrays for tracking the edges of the advancing convex hull\n\n    this._hashSize = Math.ceil(Math.sqrt(n));\n    this._hullPrev = new Uint32Array(n); // edge to prev edge\n\n    this._hullNext = new Uint32Array(n); // edge to next edge\n\n    this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n\n    this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash\n    // temporary arrays for sorting points\n\n    this._ids = new Uint32Array(n);\n    this._dists = new Float64Array(n);\n    this.update();\n  };\n\n  Delaunator.from = function from(points, getX, getY) {\n    if (getX === void 0) getX = defaultGetX;\n    if (getY === void 0) getY = defaultGetY;\n    var n = points.length;\n    var coords = new Float64Array(n * 2);\n\n    for (var i = 0; i < n; i++) {\n      var p = points[i];\n      coords[2 * i] = getX(p);\n      coords[2 * i + 1] = getY(p);\n    }\n\n    return new Delaunator(coords);\n  };\n\n  Delaunator.prototype.update = function update() {\n    var ref = this;\n    var coords = ref.coords;\n    var hullPrev = ref._hullPrev;\n    var hullNext = ref._hullNext;\n    var hullTri = ref._hullTri;\n    var hullHash = ref._hullHash;\n    var n = coords.length >> 1; // populate an array of point indices; calculate input data bbox\n\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    for (var i = 0; i < n; i++) {\n      var x = coords[2 * i];\n      var y = coords[2 * i + 1];\n\n      if (x < minX) {\n        minX = x;\n      }\n\n      if (y < minY) {\n        minY = y;\n      }\n\n      if (x > maxX) {\n        maxX = x;\n      }\n\n      if (y > maxY) {\n        maxY = y;\n      }\n\n      this._ids[i] = i;\n    }\n\n    var cx = (minX + maxX) / 2;\n    var cy = (minY + maxY) / 2;\n    var minDist = Infinity;\n    var i0, i1, i2; // pick a seed point close to the center\n\n    for (var i$1 = 0; i$1 < n; i$1++) {\n      var d = dist(cx, cy, coords[2 * i$1], coords[2 * i$1 + 1]);\n\n      if (d < minDist) {\n        i0 = i$1;\n        minDist = d;\n      }\n    }\n\n    var i0x = coords[2 * i0];\n    var i0y = coords[2 * i0 + 1];\n    minDist = Infinity; // find the point closest to the seed\n\n    for (var i$2 = 0; i$2 < n; i$2++) {\n      if (i$2 === i0) {\n        continue;\n      }\n\n      var d$1 = dist(i0x, i0y, coords[2 * i$2], coords[2 * i$2 + 1]);\n\n      if (d$1 < minDist && d$1 > 0) {\n        i1 = i$2;\n        minDist = d$1;\n      }\n    }\n\n    var i1x = coords[2 * i1];\n    var i1y = coords[2 * i1 + 1];\n    var minRadius = Infinity; // find the third point which forms the smallest circumcircle with the first two\n\n    for (var i$3 = 0; i$3 < n; i$3++) {\n      if (i$3 === i0 || i$3 === i1) {\n        continue;\n      }\n\n      var r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i$3], coords[2 * i$3 + 1]);\n\n      if (r < minRadius) {\n        i2 = i$3;\n        minRadius = r;\n      }\n    }\n\n    var i2x = coords[2 * i2];\n    var i2y = coords[2 * i2 + 1];\n\n    if (minRadius === Infinity) {\n      // order collinear points by dx (or dy if all x are identical)\n      // and return the list as a hull\n      for (var i$4 = 0; i$4 < n; i$4++) {\n        this._dists[i$4] = coords[2 * i$4] - coords[0] || coords[2 * i$4 + 1] - coords[1];\n      }\n\n      quicksort(this._ids, this._dists, 0, n - 1);\n      var hull = new Uint32Array(n);\n      var j = 0;\n\n      for (var i$5 = 0, d0 = -Infinity; i$5 < n; i$5++) {\n        var id = this._ids[i$5];\n\n        if (this._dists[id] > d0) {\n          hull[j++] = id;\n          d0 = this._dists[id];\n        }\n      }\n\n      this.hull = hull.subarray(0, j);\n      this.triangles = new Uint32Array(0);\n      this.halfedges = new Uint32Array(0);\n      return;\n    } // swap the order of the seed points for counter-clockwise orientation\n\n\n    if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n      var i$6 = i1;\n      var x$1 = i1x;\n      var y$1 = i1y;\n      i1 = i2;\n      i1x = i2x;\n      i1y = i2y;\n      i2 = i$6;\n      i2x = x$1;\n      i2y = y$1;\n    }\n\n    var center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n    this._cx = center.x;\n    this._cy = center.y;\n\n    for (var i$7 = 0; i$7 < n; i$7++) {\n      this._dists[i$7] = dist(coords[2 * i$7], coords[2 * i$7 + 1], center.x, center.y);\n    } // sort the points by distance from the seed triangle circumcenter\n\n\n    quicksort(this._ids, this._dists, 0, n - 1); // set up the seed triangle as the starting hull\n\n    this._hullStart = i0;\n    var hullSize = 3;\n    hullNext[i0] = hullPrev[i2] = i1;\n    hullNext[i1] = hullPrev[i0] = i2;\n    hullNext[i2] = hullPrev[i1] = i0;\n    hullTri[i0] = 0;\n    hullTri[i1] = 1;\n    hullTri[i2] = 2;\n    hullHash.fill(-1);\n    hullHash[this._hashKey(i0x, i0y)] = i0;\n    hullHash[this._hashKey(i1x, i1y)] = i1;\n    hullHash[this._hashKey(i2x, i2y)] = i2;\n    this.trianglesLen = 0;\n\n    this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n    for (var k = 0, xp = void 0, yp = void 0; k < this._ids.length; k++) {\n      var i$8 = this._ids[k];\n      var x$2 = coords[2 * i$8];\n      var y$2 = coords[2 * i$8 + 1]; // skip near-duplicate points\n\n      if (k > 0 && Math.abs(x$2 - xp) <= EPSILON && Math.abs(y$2 - yp) <= EPSILON) {\n        continue;\n      }\n\n      xp = x$2;\n      yp = y$2; // skip seed triangle points\n\n      if (i$8 === i0 || i$8 === i1 || i$8 === i2) {\n        continue;\n      } // find a visible edge on the convex hull using edge hash\n\n\n      var start = 0;\n\n      for (var j$1 = 0, key = this._hashKey(x$2, y$2); j$1 < this._hashSize; j$1++) {\n        start = hullHash[(key + j$1) % this._hashSize];\n\n        if (start !== -1 && start !== hullNext[start]) {\n          break;\n        }\n      }\n\n      start = hullPrev[start];\n      var e = start,\n          q = void 0;\n\n      while (q = hullNext[e], !orient(x$2, y$2, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {\n        e = q;\n\n        if (e === start) {\n          e = -1;\n          break;\n        }\n      }\n\n      if (e === -1) {\n        continue;\n      } // likely a near-duplicate point; skip it\n      // add the first triangle from the point\n\n\n      var t = this._addTriangle(e, i$8, hullNext[e], -1, -1, hullTri[e]); // recursively flip triangles from the point until they satisfy the Delaunay condition\n\n\n      hullTri[i$8] = this._legalize(t + 2);\n      hullTri[e] = t; // keep track of boundary triangles on the hull\n\n      hullSize++; // walk forward through the hull, adding more triangles and flipping recursively\n\n      var n$1 = hullNext[e];\n\n      while (q = hullNext[n$1], orient(x$2, y$2, coords[2 * n$1], coords[2 * n$1 + 1], coords[2 * q], coords[2 * q + 1])) {\n        t = this._addTriangle(n$1, i$8, q, hullTri[i$8], -1, hullTri[n$1]);\n        hullTri[i$8] = this._legalize(t + 2);\n        hullNext[n$1] = n$1; // mark as removed\n\n        hullSize--;\n        n$1 = q;\n      } // walk backward from the other side, adding more triangles and flipping\n\n\n      if (e === start) {\n        while (q = hullPrev[e], orient(x$2, y$2, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {\n          t = this._addTriangle(q, i$8, e, -1, hullTri[e], hullTri[q]);\n\n          this._legalize(t + 2);\n\n          hullTri[q] = t;\n          hullNext[e] = e; // mark as removed\n\n          hullSize--;\n          e = q;\n        }\n      } // update the hull indices\n\n\n      this._hullStart = hullPrev[i$8] = e;\n      hullNext[e] = hullPrev[n$1] = i$8;\n      hullNext[i$8] = n$1; // save the two new edges in the hash table\n\n      hullHash[this._hashKey(x$2, y$2)] = i$8;\n      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n    }\n\n    this.hull = new Uint32Array(hullSize);\n\n    for (var i$9 = 0, e$1 = this._hullStart; i$9 < hullSize; i$9++) {\n      this.hull[i$9] = e$1;\n      e$1 = hullNext[e$1];\n    } // trim typed triangle mesh arrays\n\n\n    this.triangles = this._triangles.subarray(0, this.trianglesLen);\n    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n  };\n\n  Delaunator.prototype._hashKey = function _hashKey(x, y) {\n    return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n  };\n\n  Delaunator.prototype._legalize = function _legalize(a) {\n    var ref = this;\n    var triangles = ref._triangles;\n    var halfedges = ref._halfedges;\n    var coords = ref.coords;\n    var i = 0;\n    var ar = 0; // recursion eliminated with a fixed-size stack\n\n    while (true) {\n      var b = halfedges[a];\n      /* if the pair of triangles doesn't satisfy the Delaunay condition\n       * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n       * then do the same check/flip recursively for the new pair of triangles\n       *\n       *       pl                pl\n       *      /||\\              /  \\\n       *   al/ || \\bl        al/\\a\n       *    /  ||  \\          /  \\\n       *   /  a||b  \\flip/___ar___\\\n       * p0\\   ||   /p1   =>   p0\\---bl---/p1\n       *    \\  ||  /          \\  /\n       *   ar\\ || /br         b\\/br\n       *      \\||/              \\  /\n       *       pr                pr\n       */\n\n      var a0 = a - a % 3;\n      ar = a0 + (a + 2) % 3;\n\n      if (b === -1) {\n        // convex hull edge\n        if (i === 0) {\n          break;\n        }\n\n        a = EDGE_STACK[--i];\n        continue;\n      }\n\n      var b0 = b - b % 3;\n      var al = a0 + (a + 1) % 3;\n      var bl = b0 + (b + 2) % 3;\n      var p0 = triangles[ar];\n      var pr = triangles[a];\n      var pl = triangles[al];\n      var p1 = triangles[bl];\n      var illegal = inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);\n\n      if (illegal) {\n        triangles[a] = p1;\n        triangles[b] = p0;\n        var hbl = halfedges[bl]; // edge swapped on the other side of the hull (rare); fix the halfedge reference\n\n        if (hbl === -1) {\n          var e = this._hullStart;\n\n          do {\n            if (this._hullTri[e] === bl) {\n              this._hullTri[e] = a;\n              break;\n            }\n\n            e = this._hullPrev[e];\n          } while (e !== this._hullStart);\n        }\n\n        this._link(a, hbl);\n\n        this._link(b, halfedges[ar]);\n\n        this._link(ar, bl);\n\n        var br = b0 + (b + 1) % 3; // don't worry about hitting the cap: it can only happen on extremely degenerate input\n\n        if (i < EDGE_STACK.length) {\n          EDGE_STACK[i++] = br;\n        }\n      } else {\n        if (i === 0) {\n          break;\n        }\n\n        a = EDGE_STACK[--i];\n      }\n    }\n\n    return ar;\n  };\n\n  Delaunator.prototype._link = function _link(a, b) {\n    this._halfedges[a] = b;\n\n    if (b !== -1) {\n      this._halfedges[b] = a;\n    }\n  }; // add a new triangle given vertex indices and adjacent half-edge ids\n\n\n  Delaunator.prototype._addTriangle = function _addTriangle(i0, i1, i2, a, b, c) {\n    var t = this.trianglesLen;\n    this._triangles[t] = i0;\n    this._triangles[t + 1] = i1;\n    this._triangles[t + 2] = i2;\n\n    this._link(t, a);\n\n    this._link(t + 1, b);\n\n    this._link(t + 2, c);\n\n    this.trianglesLen += 3;\n    return t;\n  }; // monotonically increases with real angle, but doesn't need expensive trigonometry\n\n\n  function pseudoAngle(dx, dy) {\n    var p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n  }\n\n  function dist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n  } // return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check\n\n\n  function orientIfSure(px, py, rx, ry, qx, qy) {\n    var l = (ry - py) * (qx - px);\n    var r = (rx - px) * (qy - py);\n    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;\n  } // a more robust orientation test that's stable in a given triangle (to fix robustness issues)\n\n\n  function orient(rx, ry, qx, qy, px, py) {\n    var sign = orientIfSure(px, py, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px, py) || orientIfSure(qx, qy, px, py, rx, ry);\n    return sign < 0;\n  }\n\n  function inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    var dx = ax - px;\n    var dy = ay - py;\n    var ex = bx - px;\n    var ey = by - py;\n    var fx = cx - px;\n    var fy = cy - py;\n    var ap = dx * dx + dy * dy;\n    var bp = ex * ex + ey * ey;\n    var cp = fx * fx + fy * fy;\n    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;\n  }\n\n  function circumradius(ax, ay, bx, by, cx, cy) {\n    var dx = bx - ax;\n    var dy = by - ay;\n    var ex = cx - ax;\n    var ey = cy - ay;\n    var bl = dx * dx + dy * dy;\n    var cl = ex * ex + ey * ey;\n    var d = 0.5 / (dx * ey - dy * ex);\n    var x = (ey * bl - dy * cl) * d;\n    var y = (dx * cl - ex * bl) * d;\n    return x * x + y * y;\n  }\n\n  function circumcenter(ax, ay, bx, by, cx, cy) {\n    var dx = bx - ax;\n    var dy = by - ay;\n    var ex = cx - ax;\n    var ey = cy - ay;\n    var bl = dx * dx + dy * dy;\n    var cl = ex * ex + ey * ey;\n    var d = 0.5 / (dx * ey - dy * ex);\n    var x = ax + (ey * bl - dy * cl) * d;\n    var y = ay + (dx * cl - ex * bl) * d;\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  function quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n      for (var i = left + 1; i <= right; i++) {\n        var temp = ids[i];\n        var tempDist = dists[temp];\n        var j = i - 1;\n\n        while (j >= left && dists[ids[j]] > tempDist) {\n          ids[j + 1] = ids[j--];\n        }\n\n        ids[j + 1] = temp;\n      }\n    } else {\n      var median = left + right >> 1;\n      var i$1 = left + 1;\n      var j$1 = right;\n      swap(ids, median, i$1);\n\n      if (dists[ids[left]] > dists[ids[right]]) {\n        swap(ids, left, right);\n      }\n\n      if (dists[ids[i$1]] > dists[ids[right]]) {\n        swap(ids, i$1, right);\n      }\n\n      if (dists[ids[left]] > dists[ids[i$1]]) {\n        swap(ids, left, i$1);\n      }\n\n      var temp$1 = ids[i$1];\n      var tempDist$1 = dists[temp$1];\n\n      while (true) {\n        do {\n          i$1++;\n        } while (dists[ids[i$1]] < tempDist$1);\n\n        do {\n          j$1--;\n        } while (dists[ids[j$1]] > tempDist$1);\n\n        if (j$1 < i$1) {\n          break;\n        }\n\n        swap(ids, i$1, j$1);\n      }\n\n      ids[left + 1] = ids[j$1];\n      ids[j$1] = temp$1;\n\n      if (right - i$1 + 1 >= j$1 - left) {\n        quicksort(ids, dists, i$1, right);\n        quicksort(ids, dists, left, j$1 - 1);\n      } else {\n        quicksort(ids, dists, left, j$1 - 1);\n        quicksort(ids, dists, i$1, right);\n      }\n    }\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n  function defaultGetX(p) {\n    return p[0];\n  }\n\n  function defaultGetY(p) {\n    return p[1];\n  }\n\n  return Delaunator;\n});","map":{"version":3,"sources":["C:/Users/31622/Documents/React Apps/portfolio/node_modules/delaunator/delaunator.js"],"names":["global","factory","exports","module","define","amd","self","Delaunator","EPSILON","Math","pow","EDGE_STACK","Uint32Array","coords","n","length","Error","maxTriangles","max","_triangles","_halfedges","Int32Array","_hashSize","ceil","sqrt","_hullPrev","_hullNext","_hullTri","_hullHash","fill","_ids","_dists","Float64Array","update","from","points","getX","getY","defaultGetX","defaultGetY","i","p","prototype","ref","hullPrev","hullNext","hullTri","hullHash","minX","Infinity","minY","maxX","maxY","x","y","cx","cy","minDist","i0","i1","i2","i$1","d","dist","i0x","i0y","i$2","d$1","i1x","i1y","minRadius","i$3","r","circumradius","i2x","i2y","i$4","quicksort","hull","j","i$5","d0","id","subarray","triangles","halfedges","orient","i$6","x$1","y$1","center","circumcenter","_cx","_cy","i$7","_hullStart","hullSize","_hashKey","trianglesLen","_addTriangle","k","xp","yp","i$8","x$2","y$2","abs","start","j$1","key","e","q","t","_legalize","n$1","i$9","e$1","floor","pseudoAngle","a","ar","b","a0","b0","al","bl","p0","pr","pl","p1","illegal","inCircle","hbl","_link","br","c","dx","dy","ax","ay","bx","by","orientIfSure","px","py","rx","ry","qx","qy","l","sign","ex","ey","fx","fy","ap","bp","cp","cl","ids","dists","left","right","temp","tempDist","median","swap","temp$1","tempDist$1","arr","tmp"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = global || self, global.Delaunator = factory());\n}(this, function () { 'use strict';\n\n    var EPSILON = Math.pow(2, -52);\n    var EDGE_STACK = new Uint32Array(512);\n\n    var Delaunator = function Delaunator(coords) {\n        var n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') { throw new Error('Expected coords to contain numbers.'); }\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        var maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    };\n\n    Delaunator.from = function from (points, getX, getY) {\n            if ( getX === void 0 ) getX = defaultGetX;\n            if ( getY === void 0 ) getY = defaultGetY;\n\n        var n = points.length;\n        var coords = new Float64Array(n * 2);\n\n        for (var i = 0; i < n; i++) {\n            var p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    };\n\n    Delaunator.prototype.update = function update () {\n        var ref =  this;\n            var coords = ref.coords;\n            var hullPrev = ref._hullPrev;\n            var hullNext = ref._hullNext;\n            var hullTri = ref._hullTri;\n            var hullHash = ref._hullHash;\n        var n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        var minX = Infinity;\n        var minY = Infinity;\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n\n        for (var i = 0; i < n; i++) {\n            var x = coords[2 * i];\n            var y = coords[2 * i + 1];\n            if (x < minX) { minX = x; }\n            if (y < minY) { minY = y; }\n            if (x > maxX) { maxX = x; }\n            if (y > maxY) { maxY = y; }\n            this._ids[i] = i;\n        }\n        var cx = (minX + maxX) / 2;\n        var cy = (minY + maxY) / 2;\n\n        var minDist = Infinity;\n        var i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (var i$1 = 0; i$1 < n; i$1++) {\n            var d = dist(cx, cy, coords[2 * i$1], coords[2 * i$1 + 1]);\n            if (d < minDist) {\n                i0 = i$1;\n                minDist = d;\n            }\n        }\n        var i0x = coords[2 * i0];\n        var i0y = coords[2 * i0 + 1];\n\n        minDist = Infinity;\n\n        // find the point closest to the seed\n        for (var i$2 = 0; i$2 < n; i$2++) {\n            if (i$2 === i0) { continue; }\n            var d$1 = dist(i0x, i0y, coords[2 * i$2], coords[2 * i$2 + 1]);\n            if (d$1 < minDist && d$1 > 0) {\n                i1 = i$2;\n                minDist = d$1;\n            }\n        }\n        var i1x = coords[2 * i1];\n        var i1y = coords[2 * i1 + 1];\n\n        var minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (var i$3 = 0; i$3 < n; i$3++) {\n            if (i$3 === i0 || i$3 === i1) { continue; }\n            var r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i$3], coords[2 * i$3 + 1]);\n            if (r < minRadius) {\n                i2 = i$3;\n                minRadius = r;\n            }\n        }\n        var i2x = coords[2 * i2];\n        var i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (var i$4 = 0; i$4 < n; i$4++) {\n                this._dists[i$4] = (coords[2 * i$4] - coords[0]) || (coords[2 * i$4 + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            var hull = new Uint32Array(n);\n            var j = 0;\n            for (var i$5 = 0, d0 = -Infinity; i$5 < n; i$5++) {\n                var id = this._ids[i$5];\n                if (this._dists[id] > d0) {\n                    hull[j++] = id;\n                    d0 = this._dists[id];\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n            var i$6 = i1;\n            var x$1 = i1x;\n            var y$1 = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i$6;\n            i2x = x$1;\n            i2y = y$1;\n        }\n\n        var center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (var i$7 = 0; i$7 < n; i$7++) {\n            this._dists[i$7] = dist(coords[2 * i$7], coords[2 * i$7 + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        var hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (var k = 0, xp = (void 0), yp = (void 0); k < this._ids.length; k++) {\n            var i$8 = this._ids[k];\n            var x$2 = coords[2 * i$8];\n            var y$2 = coords[2 * i$8 + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x$2 - xp) <= EPSILON && Math.abs(y$2 - yp) <= EPSILON) { continue; }\n            xp = x$2;\n            yp = y$2;\n\n            // skip seed triangle points\n            if (i$8 === i0 || i$8 === i1 || i$8 === i2) { continue; }\n\n            // find a visible edge on the convex hull using edge hash\n            var start = 0;\n            for (var j$1 = 0, key = this._hashKey(x$2, y$2); j$1 < this._hashSize; j$1++) {\n                start = hullHash[(key + j$1) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) { break; }\n            }\n\n            start = hullPrev[start];\n            var e = start, q = (void 0);\n            while (q = hullNext[e], !orient(x$2, y$2, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) { continue; } // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            var t = this._addTriangle(e, i$8, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i$8] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            var n$1 = hullNext[e];\n            while (q = hullNext[n$1], orient(x$2, y$2, coords[2 * n$1], coords[2 * n$1 + 1], coords[2 * q], coords[2 * q + 1])) {\n                t = this._addTriangle(n$1, i$8, q, hullTri[i$8], -1, hullTri[n$1]);\n                hullTri[i$8] = this._legalize(t + 2);\n                hullNext[n$1] = n$1; // mark as removed\n                hullSize--;\n                n$1 = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient(x$2, y$2, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {\n                    t = this._addTriangle(q, i$8, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i$8] = e;\n            hullNext[e] = hullPrev[n$1] = i$8;\n            hullNext[i$8] = n$1;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x$2, y$2)] = i$8;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (var i$9 = 0, e$1 = this._hullStart; i$9 < hullSize; i$9++) {\n            this.hull[i$9] = e$1;\n            e$1 = hullNext[e$1];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    };\n\n    Delaunator.prototype._hashKey = function _hashKey (x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    };\n\n    Delaunator.prototype._legalize = function _legalize (a) {\n        var ref = this;\n            var triangles = ref._triangles;\n            var halfedges = ref._halfedges;\n            var coords = ref.coords;\n\n        var i = 0;\n        var ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            var b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *       pl                pl\n             *      /||\\              /  \\\n             *   al/ || \\bl        al/\\a\n             *    /  ||  \\          /  \\\n             *   /  a||b  \\flip/___ar___\\\n             * p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *    \\  ||  /          \\  /\n             *   ar\\ || /br         b\\/br\n             *      \\||/              \\  /\n             *       pr                pr\n             */\n            var a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) { break; }\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            var b0 = b - b % 3;\n            var al = a0 + (a + 1) % 3;\n            var bl = b0 + (b + 2) % 3;\n\n            var p0 = triangles[ar];\n            var pr = triangles[a];\n            var pl = triangles[al];\n            var p1 = triangles[bl];\n\n            var illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                var hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    var e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                var br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) { break; }\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    };\n\n    Delaunator.prototype._link = function _link (a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) { this._halfedges[b] = a; }\n    };\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    Delaunator.prototype._addTriangle = function _addTriangle (i0, i1, i2, a, b, c) {\n        var t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    };\n\n    // monotonically increases with real angle, but doesn't need expensive trigonometry\n    function pseudoAngle(dx, dy) {\n        var p = dx / (Math.abs(dx) + Math.abs(dy));\n        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n    }\n\n    function dist(ax, ay, bx, by) {\n        var dx = ax - bx;\n        var dy = ay - by;\n        return dx * dx + dy * dy;\n    }\n\n    // return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check\n    function orientIfSure(px, py, rx, ry, qx, qy) {\n        var l = (ry - py) * (qx - px);\n        var r = (rx - px) * (qy - py);\n        return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;\n    }\n\n    // a more robust orientation test that's stable in a given triangle (to fix robustness issues)\n    function orient(rx, ry, qx, qy, px, py) {\n        var sign = orientIfSure(px, py, rx, ry, qx, qy) ||\n        orientIfSure(rx, ry, qx, qy, px, py) ||\n        orientIfSure(qx, qy, px, py, rx, ry);\n        return sign < 0;\n    }\n\n    function inCircle(ax, ay, bx, by, cx, cy, px, py) {\n        var dx = ax - px;\n        var dy = ay - py;\n        var ex = bx - px;\n        var ey = by - py;\n        var fx = cx - px;\n        var fy = cy - py;\n\n        var ap = dx * dx + dy * dy;\n        var bp = ex * ex + ey * ey;\n        var cp = fx * fx + fy * fy;\n\n        return dx * (ey * cp - bp * fy) -\n               dy * (ex * cp - bp * fx) +\n               ap * (ex * fy - ey * fx) < 0;\n    }\n\n    function circumradius(ax, ay, bx, by, cx, cy) {\n        var dx = bx - ax;\n        var dy = by - ay;\n        var ex = cx - ax;\n        var ey = cy - ay;\n\n        var bl = dx * dx + dy * dy;\n        var cl = ex * ex + ey * ey;\n        var d = 0.5 / (dx * ey - dy * ex);\n\n        var x = (ey * bl - dy * cl) * d;\n        var y = (dx * cl - ex * bl) * d;\n\n        return x * x + y * y;\n    }\n\n    function circumcenter(ax, ay, bx, by, cx, cy) {\n        var dx = bx - ax;\n        var dy = by - ay;\n        var ex = cx - ax;\n        var ey = cy - ay;\n\n        var bl = dx * dx + dy * dy;\n        var cl = ex * ex + ey * ey;\n        var d = 0.5 / (dx * ey - dy * ex);\n\n        var x = ax + (ey * bl - dy * cl) * d;\n        var y = ay + (dx * cl - ex * bl) * d;\n\n        return {x: x, y: y};\n    }\n\n    function quicksort(ids, dists, left, right) {\n        if (right - left <= 20) {\n            for (var i = left + 1; i <= right; i++) {\n                var temp = ids[i];\n                var tempDist = dists[temp];\n                var j = i - 1;\n                while (j >= left && dists[ids[j]] > tempDist) { ids[j + 1] = ids[j--]; }\n                ids[j + 1] = temp;\n            }\n        } else {\n            var median = (left + right) >> 1;\n            var i$1 = left + 1;\n            var j$1 = right;\n            swap(ids, median, i$1);\n            if (dists[ids[left]] > dists[ids[right]]) { swap(ids, left, right); }\n            if (dists[ids[i$1]] > dists[ids[right]]) { swap(ids, i$1, right); }\n            if (dists[ids[left]] > dists[ids[i$1]]) { swap(ids, left, i$1); }\n\n            var temp$1 = ids[i$1];\n            var tempDist$1 = dists[temp$1];\n            while (true) {\n                do { i$1++; } while (dists[ids[i$1]] < tempDist$1);\n                do { j$1--; } while (dists[ids[j$1]] > tempDist$1);\n                if (j$1 < i$1) { break; }\n                swap(ids, i$1, j$1);\n            }\n            ids[left + 1] = ids[j$1];\n            ids[j$1] = temp$1;\n\n            if (right - i$1 + 1 >= j$1 - left) {\n                quicksort(ids, dists, i$1, right);\n                quicksort(ids, dists, left, j$1 - 1);\n            } else {\n                quicksort(ids, dists, left, j$1 - 1);\n                quicksort(ids, dists, i$1, right);\n            }\n        }\n    }\n\n    function swap(arr, i, j) {\n        var tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    function defaultGetX(p) {\n        return p[0];\n    }\n    function defaultGetY(p) {\n        return p[1];\n    }\n\n    return Delaunator;\n\n}));\n"]},"metadata":{},"sourceType":"script"}